# Функция scale() позволяет совершить стандартизацию вектора, то есть делает его среднее значение равным нулю, 
# а стандартное отклонение - единице (Z-преобразование).
# Стандартизованный коэффициент регрессии (β) можно получить, если предикторы и зависимая переменная стандартизованы.
# Напишите функцию, которая на вход получает dataframe с двумя количественными переменными,
# а возвращает стандартизованные коэффициенты для регрессионной модели, 
# в которой первая переменная датафрейма выступает в качестве зависимой, а вторая в качестве независимой.
lm(scale(x[[2]]) ~ scale(x[[1]]), x)$coefficients
# vs
x <-scale(x)    
lm(x[,1] ~ x[,2])$coefficients

# Напишите функцию normality.test, которая получает на вход dataframe с количественными переменными, 
# проверяет распределения каждой переменной на нормальность с помощью функции shapiro.test. 
# Функция должна возвращать вектор с значениями p - value, полученного в результате проверки на нормальность каждой переменной. 
# Названия элементов вектора должны совпадать с названиями переменных. 
normality.test  <- function(x){
    sapply(x, function(y) { shapiro.test(y)$p.value })
}
# vs
normality.test  <- function(x){    
	return(sapply(x, FUN =  shapiro.test)['p.value',])}

# Загрузите себе прикреплённый к этому степу датасет и постройте регрессию, предсказывающую DV по IV. 
# Установите библиотеку gvlma и проверьте, удовлетворяется ли в этой модели требование гомоскедастичности. 
# Введите в поле ответа p-значение для теста гетероскедастичности.
library(gvlma)
step7 <- read.csv("https://stepic.org/media/attachments/lesson/12088/homosc.csv", sep=',' )
step7_x <- lm(DV ~ IV, step7)
step7_x1 <- gvlma(step7_x)
summary(step7_x1)

# Напишите функцию resid.norm, которая тестирует распределение остатков от модели на нормальность при помощи функции shapiro.test 
# и создает гистограмму при помощи функции ggplot() с красной заливкой "red", 
# если распределение остатков значимо отличается от нормального (p < 0.05), 
# и с зелёной заливкой "green" - если распределение остатков значимо не отличается от нормального.
resid.norm <- function(fit) {
  res <- shapiro.test(fit$residuals)
  df <- data.frame(fit$residuals)
  return (ggplot(df, aes(fit$residuals)) + geom_histogram(bins=30, fill=ifelse(res$p.value < 0.05, 'red', 'green')))
}
# vs
resid.norm <- function(fit) {    
	resid.norm.pv <- shapiro.test(fit$residuals)$p.value    
	plt <- ggplot(data.frame(fit$model), aes(x = fit$residuals)) +    
		geom_histogram(fill = ifelse(resid.norm.pv < 0.05, 'red', 'green'))    
	return(plt)}

# Ещё одной проблемой регрессионных моделей может стать мультиколлинеарность - ситуация, 
# когда предикторы очень сильно коррелируют между собой.
# Иногда корреляция между двумя предикторами может достигать 1, например, когда два предиктора - это одна и та же переменная, 
# измеренная в разных шкалах (x1 - рост в метрах, x2 - рост в сантиметрах)
# Проверить данные на мультиколлинеарность можно по графику pairs() и посчитав корреляцию между всеми предикторами c помощью функции cor.
# Напишите функцию high.corr, которая принимает на вход датасет с произвольным числом количественных переменных 
# и возвращает вектор с именами двух переменных с максимальным абсолютным значением коэффициента корреляции.
high.corr <- function(x){    
  num_var <- sapply(x, function(x) is.numeric(x))    
  cor_mat <- cor(x[, num_var])    
  diag(cor_mat) <- 0
  u <- which(abs(cor_mat) == max(abs(cor_mat)), arr.ind = TRUE)
  return(rownames(u))
}
 # vs   
 high.corr <- function(x){    
	cr <- cor(x)    
	diag(cr) <- 0    
	return(rownames(which(abs(cr)==max(abs(cr)),arr.ind=T)))}   